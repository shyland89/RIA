{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/lib/supabase/server.ts"],"sourcesContent":["import \"server-only\";\nimport { createServerClient } from \"@supabase/ssr\";\nimport { cookies } from \"next/headers\";\n\nexport async function createClient() {\n  const cookieStore = await cookies();\n\n  return createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return cookieStore.getAll();\n        },\n        setAll(cookiesToSet) {\n          try {\n            cookiesToSet.forEach(({ name, value, options }) =>\n              cookieStore.set(name, value, options)\n            );\n          } catch {\n            // Called from a Server Component — safe to ignore.\n          }\n        },\n      },\n    }\n  );\n}"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;AACA;;;;AAEO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,4IAAO;IAEjC,OAAO,IAAA,iMAAkB,sUAGvB;QACE,SAAS;YACP;gBACE,OAAO,YAAY,MAAM;YAC3B;YACA,QAAO,YAAY;gBACjB,IAAI;oBACF,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,GAC5C,YAAY,GAAG,CAAC,MAAM,OAAO;gBAEjC,EAAE,OAAM;gBACN,mDAAmD;gBACrD;YACF;QACF;IACF;AAEJ"}},
    {"offset": {"line": 78, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/lib/get-user-org.ts"],"sourcesContent":["import { createClient } from \"@/lib/supabase/server\";\nimport { createClient as createSupabaseClient } from \"@supabase/supabase-js\";\n\nexport type UserOrg = {\n  user: { id: string; email: string };\n  membership: { org_id: string; role: string };\n  org: { id: string; name: string };\n};\n\nexport type UserOrgError = {\n  error: string;\n  status: number;\n};\n\nfunction createAdminClient() {\n  return createSupabaseClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.SUPABASE_SERVICE_ROLE_KEY!\n  );\n}\n\nexport async function getUserOrg(): Promise<UserOrg | UserOrgError> {\n  const supabase = await createClient();\n\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    return { error: \"Unauthorized\", status: 401 };\n  }\n\n  const admin = createAdminClient();\n\n  const { data: membership, error: memError } = await admin\n    .from(\"memberships\")\n    .select(\"org_id, role\")\n    .eq(\"user_id\", user.id)\n    .limit(1)\n    .maybeSingle();\n\n  if (memError || !membership) {\n    return {\n      error: \"No membership found. You may need to create an organization or contact support.\",\n      status: 403,\n    };\n  }\n\n  const { data: org, error: orgError } = await admin\n    .from(\"organizations\")\n    .select(\"id, name\")\n    .eq(\"id\", membership.org_id)\n    .limit(1)\n    .maybeSingle();\n\n  if (orgError || !org) {\n    return {\n      error: \"Organization record not found. Please contact support.\",\n      status: 500,\n    };\n  }\n\n  return {\n    user: { id: user.id, email: user.email ?? \"\" },\n    membership: { org_id: membership.org_id, role: membership.role },\n    org: { id: org.id, name: org.name },\n  };\n}\n\nexport function isUserOrgError(result: UserOrg | UserOrgError): result is UserOrgError {\n  return \"error\" in result;\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAaA,SAAS;IACP,OAAO,IAAA,gMAAoB,gFAEzB,QAAQ,GAAG,CAAC,yBAAyB;AAEzC;AAEO,eAAe;IACpB,MAAM,WAAW,MAAM,IAAA,2IAAY;IAEnC,MAAM,EACJ,MAAM,EAAE,IAAI,EAAE,EACf,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;IAE/B,IAAI,CAAC,MAAM;QACT,OAAO;YAAE,OAAO;YAAgB,QAAQ;QAAI;IAC9C;IAEA,MAAM,QAAQ;IAEd,MAAM,EAAE,MAAM,UAAU,EAAE,OAAO,QAAQ,EAAE,GAAG,MAAM,MACjD,IAAI,CAAC,eACL,MAAM,CAAC,gBACP,EAAE,CAAC,WAAW,KAAK,EAAE,EACrB,KAAK,CAAC,GACN,WAAW;IAEd,IAAI,YAAY,CAAC,YAAY;QAC3B,OAAO;YACL,OAAO;YACP,QAAQ;QACV;IACF;IAEA,MAAM,EAAE,MAAM,GAAG,EAAE,OAAO,QAAQ,EAAE,GAAG,MAAM,MAC1C,IAAI,CAAC,iBACL,MAAM,CAAC,YACP,EAAE,CAAC,MAAM,WAAW,MAAM,EAC1B,KAAK,CAAC,GACN,WAAW;IAEd,IAAI,YAAY,CAAC,KAAK;QACpB,OAAO;YACL,OAAO;YACP,QAAQ;QACV;IACF;IAEA,OAAO;QACL,MAAM;YAAE,IAAI,KAAK,EAAE;YAAE,OAAO,KAAK,KAAK,IAAI;QAAG;QAC7C,YAAY;YAAE,QAAQ,WAAW,MAAM;YAAE,MAAM,WAAW,IAAI;QAAC;QAC/D,KAAK;YAAE,IAAI,IAAI,EAAE;YAAE,MAAM,IAAI,IAAI;QAAC;IACpC;AACF;AAEO,SAAS,eAAe,MAA8B;IAC3D,OAAO,WAAW;AACpB"}},
    {"offset": {"line": 137, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/lib/enrichment.ts"],"sourcesContent":["import OpenAI from \"openai\";\n\n// ─── Industry Cluster Taxonomy (NACE-backed, sales-readable labels) ───────────\n\nexport const INDUSTRY_CLUSTERS = [\n  \"Technology & Software\",\n  \"Financial Services\",\n  \"Professional Services\",\n  \"Healthcare & Life Sciences\",\n  \"Retail & E-commerce\",\n  \"Manufacturing & Industrial\",\n  \"Media & Advertising\",\n  \"Logistics & Transport\",\n  \"Construction & Real Estate\",\n  \"Hospitality & Travel\",\n  \"Public Sector & Education\",\n  \"Telecommunications\",\n  \"Energy & Utilities\",\n  \"Other\",\n] as const;\n\nexport type IndustryCluster = (typeof INDUSTRY_CLUSTERS)[number];\n\n// ─── Source Group Taxonomy ────────────────────────────────────────────────────\n\nexport const SOURCE_GROUPS = [\"inbound\", \"outbound\", \"other\"] as const;\nexport type SourceGroup = (typeof SOURCE_GROUPS)[number];\n\nexport const SOURCE_GROUP_LABELS: Record<SourceGroup, string> = {\n  inbound: \"Inbound\",\n  outbound: \"Outbound\",\n  other: \"Other\",\n};\n\n// Deterministic fallback rules — used if LLM classification fails\n// or as a pre-filter to avoid unnecessary API calls\n\nconst INBOUND_KEYWORDS = [\n  \"website\", \"web\", \"organic\", \"seo\", \"content\", \"blog\", \"social\",\n  \"paid search\", \"ppc\", \"adwords\", \"google ads\", \"paid\", \"referral\",\n  \"word of mouth\", \"wom\", \"review\", \"g2\", \"capterra\", \"inbound\",\n  \"marketing\", \"newsletter\", \"webinar\", \"conference inbound\",\n];\n\nconst OUTBOUND_KEYWORDS = [\n  \"outbound\", \"cold\", \"sdr\", \"bdr\", \"ae\", \"prospecting\", \"sequence\",\n  \"cadence\", \"linkedin\", \"email outreach\", \"cold email\", \"cold call\",\n  \"phone\", \"direct\", \"sales rep\", \"sales development\",\n];\n\nexport function inferSourceGroupDeterministic(rawSource: string): SourceGroup | null {\n  const lower = rawSource.toLowerCase().trim();\n  if (INBOUND_KEYWORDS.some((k) => lower.includes(k))) return \"inbound\";\n  if (OUTBOUND_KEYWORDS.some((k) => lower.includes(k))) return \"outbound\";\n  return null;\n}\n\n// ─── Enrichment Result Types ──────────────────────────────────────────────────\n\nexport type IndustryMapping = Record<string, IndustryCluster>; // raw → cluster\nexport type SourceMapping = Record<string, SourceGroup>;       // raw → group\n\nexport type EnrichmentMapping = {\n  industry: IndustryMapping;\n  source: SourceMapping;\n};\n\n// ─── LLM Classification ───────────────────────────────────────────────────────\n\n/**\n * Classify unique raw industry and source values into clusters.\n * Returns deterministic fallback for source values it can resolve without LLM.\n * Runs a single batched LLM call for everything else.\n */\nexport async function classifyEnrichmentValues(\n  uniqueIndustries: string[],\n  uniqueSources: string[],\n  apiKey: string\n): Promise<EnrichmentMapping> {\n  // Pre-resolve sources deterministically\n  const sourceMapping: SourceMapping = {};\n  const sourcesNeedingLLM: string[] = [];\n\n  for (const s of uniqueSources) {\n    const det = inferSourceGroupDeterministic(s);\n    if (det) {\n      sourceMapping[s] = det;\n    } else {\n      sourcesNeedingLLM.push(s);\n    }\n  }\n\n  // If nothing needs LLM classification, return early\n  if (uniqueIndustries.length === 0 && sourcesNeedingLLM.length === 0) {\n    return { industry: {}, source: sourceMapping };\n  }\n\n  const openai = new OpenAI({ apiKey });\n\n  const industrySection =\n    uniqueIndustries.length > 0\n      ? `INDUSTRIES TO CLASSIFY (map each to one of the clusters listed):\n${uniqueIndustries.map((i, idx) => `${idx + 1}. \"${i}\"`).join(\"\\n\")}\n\nAvailable industry clusters:\n${INDUSTRY_CLUSTERS.map((c) => `- \"${c}\"`).join(\"\\n\")}`\n      : \"\";\n\n  const sourceSection =\n    sourcesNeedingLLM.length > 0\n      ? `SOURCES TO CLASSIFY (map each to \"inbound\", \"outbound\", or \"other\"):\n${sourcesNeedingLLM.map((s, idx) => `${idx + 1}. \"${s}\"`).join(\"\\n\")}\n\nRules:\n- \"inbound\": lead came to you (website, paid search, referral, event where prospect approached, partner-sourced)\n- \"outbound\": you went to them (cold outreach, SDR sequences, cold call, LinkedIn prospecting)\n- \"other\": genuinely ambiguous or neither (e.g. \"existing customer\", \"unknown\")`\n      : \"\";\n\n  const systemPrompt = `You are a data classification assistant for a B2B sales analytics platform. \nYou receive raw values from CRM exports and map them to standardized groups.\nRespond ONLY with a valid JSON object — no explanation, no markdown.`;\n\n  const userPrompt = `Classify the following values and return a JSON object with this exact structure:\n{\n  \"industry\": { \"<raw_value>\": \"<cluster_label>\", ... },\n  \"source\": { \"<raw_value>\": \"<inbound|outbound|other>\", ... }\n}\n\n${industrySection}\n\n${sourceSection}\n\nImportant:\n- Every input value must appear as a key in the output\n- Use EXACT cluster labels from the list provided — no variations\n- If an industry is genuinely ambiguous, use \"Other\"\n- Return empty objects {} for sections with no inputs`;\n\n  try {\n    const response = await openai.chat.completions.create({\n      model: \"gpt-4o-mini\",\n      response_format: { type: \"json_object\" },\n      messages: [\n        { role: \"system\", content: systemPrompt },\n        { role: \"user\", content: userPrompt },\n      ],\n    });\n\n    const content = response.choices[0]?.message?.content;\n    if (!content) throw new Error(\"Empty response from OpenAI\");\n\n    const parsed = JSON.parse(content);\n\n    const industryMapping: IndustryMapping = {};\n    if (parsed.industry && typeof parsed.industry === \"object\") {\n      for (const [raw, cluster] of Object.entries(parsed.industry)) {\n        if (INDUSTRY_CLUSTERS.includes(cluster as IndustryCluster)) {\n          industryMapping[raw] = cluster as IndustryCluster;\n        } else {\n          industryMapping[raw] = \"Other\";\n        }\n      }\n    }\n\n    // Merge LLM source results with deterministic ones\n    if (parsed.source && typeof parsed.source === \"object\") {\n      for (const [raw, group] of Object.entries(parsed.source)) {\n        if (SOURCE_GROUPS.includes(group as SourceGroup)) {\n          sourceMapping[raw] = group as SourceGroup;\n        } else {\n          sourceMapping[raw] = \"other\";\n        }\n      }\n    }\n\n    // Fill in any industries not returned by LLM\n    for (const industry of uniqueIndustries) {\n      if (!industryMapping[industry]) {\n        industryMapping[industry] = \"Other\";\n      }\n    }\n\n    return { industry: industryMapping, source: sourceMapping };\n  } catch (err) {\n    console.error(\"Enrichment classification failed:\", err);\n\n    // Full fallback — return Other for all industries, other for unresolved sources\n    const industryFallback: IndustryMapping = {};\n    for (const i of uniqueIndustries) industryFallback[i] = \"Other\";\n    for (const s of sourcesNeedingLLM) sourceMapping[s] = \"other\";\n\n    return { industry: industryFallback, source: sourceMapping };\n  }\n}\n\n/**\n * Apply enrichment mapping to a row's raw field values.\n * Returns null if the raw value isn't in the mapping.\n */\nexport function applyIndustryCluster(\n  rawIndustry: string | null | undefined,\n  mapping: IndustryMapping\n): string | null {\n  if (!rawIndustry) return null;\n  return mapping[rawIndustry] ?? null;\n}\n\nexport function applySourceGroup(\n  rawSource: string | null | undefined,\n  mapping: SourceMapping\n): SourceGroup | null {\n  if (!rawSource) return null;\n  return mapping[rawSource] ?? null;\n}\n\n/**\n * Extract unique non-null values for a given field from parsed CSV records.\n */\nexport function extractUniqueValues(\n  records: Record<string, string>[],\n  columnName: string | undefined\n): string[] {\n  if (!columnName) return [];\n  const seen = new Set<string>();\n  for (const row of records) {\n    const val = row[columnName]?.trim();\n    if (val && val !== \"\" && ![\"na\", \"n/a\", \"null\", \"none\", \"-\"].includes(val.toLowerCase())) {\n      seen.add(val);\n    }\n  }\n  return Array.from(seen);\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 378, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/api/import/execute/route.ts"],"sourcesContent":["import { createClient } from \"@/lib/supabase/server\";\nimport { getUserOrg, isUserOrgError } from \"@/lib/get-user-org\";\nimport { createClient as createSupabaseClient } from \"@supabase/supabase-js\";\nimport { NextResponse } from \"next/server\";\nimport { parse } from \"csv-parse/sync\";\nimport {\n  classifyEnrichmentValues,\n  extractUniqueValues,\n  applyIndustryCluster,\n  applySourceGroup,\n  type EnrichmentMapping,\n} from \"@/lib/enrichment\";\n\nconst REQUIRED_FIELDS = [\"name\", \"amount\", \"outcome\"] as const;\nconst OPTIONAL_DIMENSION_FIELDS = [\"role\", \"industry\", \"source\", \"segment\", \"country\"] as const;\nconst DATE_FIELDS = [\"created_at\", \"closed_date\", \"pipeline_accepted_date\"] as const;\nconst VALID_OUTCOMES = [\"open\", \"won\", \"lost\"];\nconst NULL_TOKENS = [\"\", \"na\", \"n/a\", \"null\", \"none\", \"-\"];\n\nfunction isNullish(val: string | undefined): boolean {\n  if (!val) return true;\n  return NULL_TOKENS.includes(val.trim().toLowerCase());\n}\n\nfunction normalizeDimension(val: string | undefined): string | null {\n  if (!val) return null;\n  const trimmed = val.trim();\n  if (NULL_TOKENS.includes(trimmed.toLowerCase())) return null;\n  return trimmed;\n}\n\nfunction createAdminClient() {\n  return createSupabaseClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.SUPABASE_SERVICE_ROLE_KEY!\n  );\n}\n\nexport async function POST(request: Request) {\n  const result = await getUserOrg();\n\n  if (isUserOrgError(result)) {\n    return NextResponse.json({ error: result.error }, { status: result.status });\n  }\n\n  const supabase = await createClient();\n  const admin = createAdminClient();\n  const user = result.user;\n  const orgId = result.membership.org_id;\n\n  const formData = await request.formData();\n  const file = formData.get(\"file\") as File | null;\n  const mappingJson = formData.get(\"mapping\") as string | null;\n  const enrichmentMappingJson = formData.get(\"enrichment_mapping\") as string | null;\n  const importMode = (formData.get(\"mode\") as string) || \"append\";\n\n  if (!file || !mappingJson) {\n    return NextResponse.json(\n      { error: \"File and column mapping are required\" },\n      { status: 400 }\n    );\n  }\n\n  let mapping: Record<string, string>;\n  try {\n    mapping = JSON.parse(mappingJson);\n  } catch {\n    return NextResponse.json({ error: \"Invalid mapping format\" }, { status: 400 });\n  }\n\n  // Parse user-reviewed enrichment mapping if provided\n  let userEnrichmentMapping: EnrichmentMapping | null = null;\n  if (enrichmentMappingJson) {\n    try {\n      userEnrichmentMapping = JSON.parse(enrichmentMappingJson);\n    } catch {\n      // Not fatal — will re-classify\n    }\n  }\n\n  for (const field of REQUIRED_FIELDS) {\n    if (!mapping[field]) {\n      return NextResponse.json(\n        { error: `Missing mapping for required field: ${field}` },\n        { status: 400 }\n      );\n    }\n  }\n\n  const hasAtLeastOneDate = DATE_FIELDS.some((df) => !!mapping[df]);\n  if (!hasAtLeastOneDate) {\n    return NextResponse.json(\n      { error: \"At least one date field must be mapped (created_at, closed_date, or pipeline_accepted_date)\" },\n      { status: 400 }\n    );\n  }\n\n  const text = await file.text();\n  let records: Record<string, string>[];\n  try {\n    records = parse(text, {\n      columns: true,\n      skip_empty_lines: true,\n      trim: true,\n      bom: true,\n    });\n  } catch (e: any) {\n    return NextResponse.json({ error: `CSV parse error: ${e.message}` }, { status: 400 });\n  }\n\n  // ─── Enrichment Classification ─────────────────────────────────────────────\n  // Use the user-reviewed mapping if provided; otherwise classify fresh.\n  let enrichmentMapping: EnrichmentMapping = { industry: {}, source: {} };\n\n  const apiKey = process.env.OPENAI_API_KEY;\n\n  if (userEnrichmentMapping) {\n    enrichmentMapping = userEnrichmentMapping;\n  } else if (apiKey) {\n    const uniqueIndustries = extractUniqueValues(records, mapping.industry);\n    const uniqueSources = extractUniqueValues(records, mapping.source);\n\n    if (uniqueIndustries.length > 0 || uniqueSources.length > 0) {\n      try {\n        enrichmentMapping = await classifyEnrichmentValues(\n          uniqueIndustries,\n          uniqueSources,\n          apiKey\n        );\n      } catch (err) {\n        console.error(\"Enrichment classification error (non-fatal):\", err);\n        // Continue without enrichment — enrichment fields will be null\n      }\n    }\n  }\n  // ──────────────────────────────────────────────────────────────────────────\n\n  const { data: job, error: jobError } = await admin\n    .from(\"import_jobs\")\n    .insert({\n      org_id: orgId,\n      user_id: user.id,\n      filename: file.name,\n      inserted_count: 0,\n      error_count: 0,\n      skipped_count: 0,\n      row_count: records.length,\n      status: \"running\",\n      is_active: true,\n      import_mode: importMode === \"replace\" ? \"replace\" : \"append\",\n      mapping_config: mapping,\n      enrichment_mapping: enrichmentMapping,\n      started_at: new Date().toISOString(),\n    })\n    .select(\"id\")\n    .single();\n\n  if (jobError || !job) {\n    return NextResponse.json(\n      { error: `Failed to create import job: ${jobError?.message}` },\n      { status: 500 }\n    );\n  }\n\n  const jobId = job.id;\n\n  if (importMode === \"replace\") {\n    await admin\n      .from(\"import_jobs\")\n      .update({ is_active: false })\n      .eq(\"org_id\", orgId)\n      .neq(\"id\", jobId);\n\n    const { error: deleteError } = await admin\n      .from(\"opportunities\")\n      .delete()\n      .eq(\"org_id\", orgId)\n      .is(\"import_job_id\", null);\n\n    if (deleteError) {\n      console.error(\"Failed to delete unlinked opportunities:\", deleteError.message);\n    }\n\n    const { data: priorJobs } = await admin\n      .from(\"import_jobs\")\n      .select(\"id\")\n      .eq(\"org_id\", orgId)\n      .eq(\"is_active\", false);\n\n    if (priorJobs && priorJobs.length > 0) {\n      for (const pj of priorJobs) {\n        await admin\n          .from(\"opportunities\")\n          .delete()\n          .eq(\"org_id\", orgId)\n          .eq(\"import_job_id\", pj.id);\n      }\n    }\n  }\n\n  let insertedCount = 0;\n  let skippedCount = 0;\n  const errors: { row_number: number; error_message: string; raw_row_json: any }[] = [];\n\n  for (let i = 0; i < records.length; i++) {\n    const row = records[i];\n    const rowNum = i + 2;\n    const rowErrors: string[] = [];\n\n    const name = row[mapping.name]?.trim() || \"\";\n    const amountStr = row[mapping.amount]?.trim() || \"\";\n    const outcome = row[mapping.outcome]?.trim()?.toLowerCase() || \"\";\n    const roleStr = mapping.role ? row[mapping.role]?.trim() : undefined;\n    const industryStr = mapping.industry ? row[mapping.industry]?.trim() : undefined;\n    const sourceStr = mapping.source ? row[mapping.source]?.trim() : undefined;\n    const createdAtStr = mapping.created_at ? row[mapping.created_at]?.trim() : undefined;\n    const closedDateStr = mapping.closed_date ? row[mapping.closed_date]?.trim() : undefined;\n    const pipelineDateStr = mapping.pipeline_accepted_date ? row[mapping.pipeline_accepted_date]?.trim() : undefined;\n    const segmentStr = mapping.segment ? row[mapping.segment]?.trim() : undefined;\n    const countryStr = mapping.country ? row[mapping.country]?.trim() : undefined;\n\n    if (!name) rowErrors.push(\"name is required\");\n\n    const amount = parseFloat(amountStr);\n    if (!amountStr || isNaN(amount)) {\n      rowErrors.push(\"amount must be a valid number\");\n    }\n\n    if (!VALID_OUTCOMES.includes(outcome)) {\n      rowErrors.push(`outcome must be one of: ${VALID_OUTCOMES.join(\", \")} (got \"${outcome}\")`);\n    }\n\n    let createdAt: string | undefined;\n    if (createdAtStr && !isNullish(createdAtStr)) {\n      const d = new Date(createdAtStr);\n      if (isNaN(d.getTime())) {\n        rowErrors.push(\"created_at is not a valid date\");\n      } else {\n        createdAt = d.toISOString();\n      }\n    }\n\n    let closedDate: string | undefined;\n    if (closedDateStr && !isNullish(closedDateStr)) {\n      const d = new Date(closedDateStr);\n      if (isNaN(d.getTime())) {\n        rowErrors.push(\"closed_date is not a valid date\");\n      } else {\n        closedDate = d.toISOString();\n      }\n    }\n\n    let pipelineAcceptedDate: string | undefined;\n    if (pipelineDateStr && !isNullish(pipelineDateStr)) {\n      const d = new Date(pipelineDateStr);\n      if (isNaN(d.getTime())) {\n        rowErrors.push(\"pipeline_accepted_date is not a valid date\");\n      } else {\n        pipelineAcceptedDate = d.toISOString();\n      }\n    }\n\n    if (rowErrors.length > 0) {\n      errors.push({\n        row_number: rowNum,\n        error_message: rowErrors.join(\"; \"),\n        raw_row_json: row,\n      });\n      continue;\n    }\n\n    const normalizedIndustry = normalizeDimension(industryStr);\n    const normalizedSource = normalizeDimension(sourceStr);\n\n    const insertData: any = {\n      org_id: orgId,\n      import_job_id: jobId,\n      name: name || null,\n      role: normalizeDimension(roleStr),\n      industry: normalizedIndustry,\n      source: normalizedSource,\n      amount,\n      outcome,\n      segment: normalizeDimension(segmentStr),\n      country: normalizeDimension(countryStr),\n      // Enriched fields\n      industry_cluster: applyIndustryCluster(normalizedIndustry, enrichmentMapping.industry),\n      source_group: applySourceGroup(normalizedSource, enrichmentMapping.source),\n    };\n\n    if (createdAt) insertData.created_at = createdAt;\n    if (closedDate) insertData.closed_date = closedDate;\n    if (pipelineAcceptedDate) insertData.pipeline_accepted_date = pipelineAcceptedDate;\n\n    const { error: insertError } = await admin\n      .from(\"opportunities\")\n      .insert(insertData);\n\n    if (insertError) {\n      errors.push({\n        row_number: rowNum,\n        error_message: insertError.message,\n        raw_row_json: row,\n      });\n    } else {\n      insertedCount++;\n    }\n  }\n\n  if (errors.length > 0) {\n    const errorInserts = errors.map((e) => ({\n      job_id: jobId,\n      row_number: e.row_number,\n      error_message: e.error_message,\n      raw_row_json: e.raw_row_json,\n    }));\n    await admin.from(\"import_errors\").insert(errorInserts);\n  }\n\n  const finalStatus = insertedCount > 0 ? \"completed\" : errors.length > 0 ? \"failed\" : \"completed\";\n\n  await admin\n    .from(\"import_jobs\")\n    .update({\n      inserted_count: insertedCount,\n      error_count: errors.length,\n      skipped_count: skippedCount,\n      status: finalStatus,\n      completed_at: new Date().toISOString(),\n    })\n    .eq(\"id\", jobId);\n\n  return NextResponse.json({\n    jobId,\n    insertedCount,\n    errorCount: errors.length,\n    skippedCount,\n    totalRows: records.length,\n    errors: errors.slice(0, 50),\n    enrichmentMapping, // returned so UI can display what was applied\n  });\n}"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAQA,MAAM,kBAAkB;IAAC;IAAQ;IAAU;CAAU;AACrD,MAAM,4BAA4B;IAAC;IAAQ;IAAY;IAAU;IAAW;CAAU;AACtF,MAAM,cAAc;IAAC;IAAc;IAAe;CAAyB;AAC3E,MAAM,iBAAiB;IAAC;IAAQ;IAAO;CAAO;AAC9C,MAAM,cAAc;IAAC;IAAI;IAAM;IAAO;IAAQ;IAAQ;CAAI;AAE1D,SAAS,UAAU,GAAuB;IACxC,IAAI,CAAC,KAAK,OAAO;IACjB,OAAO,YAAY,QAAQ,CAAC,IAAI,IAAI,GAAG,WAAW;AACpD;AAEA,SAAS,mBAAmB,GAAuB;IACjD,IAAI,CAAC,KAAK,OAAO;IACjB,MAAM,UAAU,IAAI,IAAI;IACxB,IAAI,YAAY,QAAQ,CAAC,QAAQ,WAAW,KAAK,OAAO;IACxD,OAAO;AACT;AAEA,SAAS;IACP,OAAO,IAAA,gMAAoB,gFAEzB,QAAQ,GAAG,CAAC,yBAAyB;AAEzC;AAEO,eAAe,KAAK,OAAgB;IACzC,MAAM,SAAS,MAAM,IAAA,yIAAU;IAE/B,IAAI,IAAA,6IAAc,EAAC,SAAS;QAC1B,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO,OAAO,KAAK;QAAC,GAAG;YAAE,QAAQ,OAAO,MAAM;QAAC;IAC5E;IAEA,MAAM,WAAW,MAAM,IAAA,2IAAY;IACnC,MAAM,QAAQ;IACd,MAAM,OAAO,OAAO,IAAI;IACxB,MAAM,QAAQ,OAAO,UAAU,CAAC,MAAM;IAEtC,MAAM,WAAW,MAAM,QAAQ,QAAQ;IACvC,MAAM,OAAO,SAAS,GAAG,CAAC;IAC1B,MAAM,cAAc,SAAS,GAAG,CAAC;IACjC,MAAM,wBAAwB,SAAS,GAAG,CAAC;IAC3C,MAAM,aAAa,AAAC,SAAS,GAAG,CAAC,WAAsB;IAEvD,IAAI,CAAC,QAAQ,CAAC,aAAa;QACzB,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAuC,GAChD;YAAE,QAAQ;QAAI;IAElB;IAEA,IAAI;IACJ,IAAI;QACF,UAAU,KAAK,KAAK,CAAC;IACvB,EAAE,OAAM;QACN,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAyB,GAAG;YAAE,QAAQ;QAAI;IAC9E;IAEA,qDAAqD;IACrD,IAAI,wBAAkD;IACtD,IAAI,uBAAuB;QACzB,IAAI;YACF,wBAAwB,KAAK,KAAK,CAAC;QACrC,EAAE,OAAM;QACN,+BAA+B;QACjC;IACF;IAEA,KAAK,MAAM,SAAS,gBAAiB;QACnC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;YACnB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO,CAAC,oCAAoC,EAAE,OAAO;YAAC,GACxD;gBAAE,QAAQ;YAAI;QAElB;IACF;IAEA,MAAM,oBAAoB,YAAY,IAAI,CAAC,CAAC,KAAO,CAAC,CAAC,OAAO,CAAC,GAAG;IAChE,IAAI,CAAC,mBAAmB;QACtB,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA8F,GACvG;YAAE,QAAQ;QAAI;IAElB;IAEA,MAAM,OAAO,MAAM,KAAK,IAAI;IAC5B,IAAI;IACJ,IAAI;QACF,UAAU,IAAA,sKAAK,EAAC,MAAM;YACpB,SAAS;YACT,kBAAkB;YAClB,MAAM;YACN,KAAK;QACP;IACF,EAAE,OAAO,GAAQ;QACf,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO,CAAC,iBAAiB,EAAE,EAAE,OAAO,EAAE;QAAC,GAAG;YAAE,QAAQ;QAAI;IACrF;IAEA,8EAA8E;IAC9E,uEAAuE;IACvE,IAAI,oBAAuC;QAAE,UAAU,CAAC;QAAG,QAAQ,CAAC;IAAE;IAEtE,MAAM,SAAS,QAAQ,GAAG,CAAC,cAAc;IAEzC,IAAI,uBAAuB;QACzB,oBAAoB;IACtB,OAAO,IAAI,QAAQ;QACjB,MAAM,mBAAmB,IAAA,0IAAmB,EAAC,SAAS,QAAQ,QAAQ;QACtE,MAAM,gBAAgB,IAAA,0IAAmB,EAAC,SAAS,QAAQ,MAAM;QAEjE,IAAI,iBAAiB,MAAM,GAAG,KAAK,cAAc,MAAM,GAAG,GAAG;YAC3D,IAAI;gBACF,oBAAoB,MAAM,IAAA,+IAAwB,EAChD,kBACA,eACA;YAEJ,EAAE,OAAO,KAAK;gBACZ,QAAQ,KAAK,CAAC,gDAAgD;YAC9D,+DAA+D;YACjE;QACF;IACF;IACA,6EAA6E;IAE7E,MAAM,EAAE,MAAM,GAAG,EAAE,OAAO,QAAQ,EAAE,GAAG,MAAM,MAC1C,IAAI,CAAC,eACL,MAAM,CAAC;QACN,QAAQ;QACR,SAAS,KAAK,EAAE;QAChB,UAAU,KAAK,IAAI;QACnB,gBAAgB;QAChB,aAAa;QACb,eAAe;QACf,WAAW,QAAQ,MAAM;QACzB,QAAQ;QACR,WAAW;QACX,aAAa,eAAe,YAAY,YAAY;QACpD,gBAAgB;QAChB,oBAAoB;QACpB,YAAY,IAAI,OAAO,WAAW;IACpC,GACC,MAAM,CAAC,MACP,MAAM;IAET,IAAI,YAAY,CAAC,KAAK;QACpB,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO,CAAC,6BAA6B,EAAE,UAAU,SAAS;QAAC,GAC7D;YAAE,QAAQ;QAAI;IAElB;IAEA,MAAM,QAAQ,IAAI,EAAE;IAEpB,IAAI,eAAe,WAAW;QAC5B,MAAM,MACH,IAAI,CAAC,eACL,MAAM,CAAC;YAAE,WAAW;QAAM,GAC1B,EAAE,CAAC,UAAU,OACb,GAAG,CAAC,MAAM;QAEb,MAAM,EAAE,OAAO,WAAW,EAAE,GAAG,MAAM,MAClC,IAAI,CAAC,iBACL,MAAM,GACN,EAAE,CAAC,UAAU,OACb,EAAE,CAAC,iBAAiB;QAEvB,IAAI,aAAa;YACf,QAAQ,KAAK,CAAC,4CAA4C,YAAY,OAAO;QAC/E;QAEA,MAAM,EAAE,MAAM,SAAS,EAAE,GAAG,MAAM,MAC/B,IAAI,CAAC,eACL,MAAM,CAAC,MACP,EAAE,CAAC,UAAU,OACb,EAAE,CAAC,aAAa;QAEnB,IAAI,aAAa,UAAU,MAAM,GAAG,GAAG;YACrC,KAAK,MAAM,MAAM,UAAW;gBAC1B,MAAM,MACH,IAAI,CAAC,iBACL,MAAM,GACN,EAAE,CAAC,UAAU,OACb,EAAE,CAAC,iBAAiB,GAAG,EAAE;YAC9B;QACF;IACF;IAEA,IAAI,gBAAgB;IACpB,IAAI,eAAe;IACnB,MAAM,SAA6E,EAAE;IAErF,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,MAAM,EAAE,IAAK;QACvC,MAAM,MAAM,OAAO,CAAC,EAAE;QACtB,MAAM,SAAS,IAAI;QACnB,MAAM,YAAsB,EAAE;QAE9B,MAAM,OAAO,GAAG,CAAC,QAAQ,IAAI,CAAC,EAAE,UAAU;QAC1C,MAAM,YAAY,GAAG,CAAC,QAAQ,MAAM,CAAC,EAAE,UAAU;QACjD,MAAM,UAAU,GAAG,CAAC,QAAQ,OAAO,CAAC,EAAE,QAAQ,iBAAiB;QAC/D,MAAM,UAAU,QAAQ,IAAI,GAAG,GAAG,CAAC,QAAQ,IAAI,CAAC,EAAE,SAAS;QAC3D,MAAM,cAAc,QAAQ,QAAQ,GAAG,GAAG,CAAC,QAAQ,QAAQ,CAAC,EAAE,SAAS;QACvE,MAAM,YAAY,QAAQ,MAAM,GAAG,GAAG,CAAC,QAAQ,MAAM,CAAC,EAAE,SAAS;QACjE,MAAM,eAAe,QAAQ,UAAU,GAAG,GAAG,CAAC,QAAQ,UAAU,CAAC,EAAE,SAAS;QAC5E,MAAM,gBAAgB,QAAQ,WAAW,GAAG,GAAG,CAAC,QAAQ,WAAW,CAAC,EAAE,SAAS;QAC/E,MAAM,kBAAkB,QAAQ,sBAAsB,GAAG,GAAG,CAAC,QAAQ,sBAAsB,CAAC,EAAE,SAAS;QACvG,MAAM,aAAa,QAAQ,OAAO,GAAG,GAAG,CAAC,QAAQ,OAAO,CAAC,EAAE,SAAS;QACpE,MAAM,aAAa,QAAQ,OAAO,GAAG,GAAG,CAAC,QAAQ,OAAO,CAAC,EAAE,SAAS;QAEpE,IAAI,CAAC,MAAM,UAAU,IAAI,CAAC;QAE1B,MAAM,SAAS,WAAW;QAC1B,IAAI,CAAC,aAAa,MAAM,SAAS;YAC/B,UAAU,IAAI,CAAC;QACjB;QAEA,IAAI,CAAC,eAAe,QAAQ,CAAC,UAAU;YACrC,UAAU,IAAI,CAAC,CAAC,wBAAwB,EAAE,eAAe,IAAI,CAAC,MAAM,OAAO,EAAE,QAAQ,EAAE,CAAC;QAC1F;QAEA,IAAI;QACJ,IAAI,gBAAgB,CAAC,UAAU,eAAe;YAC5C,MAAM,IAAI,IAAI,KAAK;YACnB,IAAI,MAAM,EAAE,OAAO,KAAK;gBACtB,UAAU,IAAI,CAAC;YACjB,OAAO;gBACL,YAAY,EAAE,WAAW;YAC3B;QACF;QAEA,IAAI;QACJ,IAAI,iBAAiB,CAAC,UAAU,gBAAgB;YAC9C,MAAM,IAAI,IAAI,KAAK;YACnB,IAAI,MAAM,EAAE,OAAO,KAAK;gBACtB,UAAU,IAAI,CAAC;YACjB,OAAO;gBACL,aAAa,EAAE,WAAW;YAC5B;QACF;QAEA,IAAI;QACJ,IAAI,mBAAmB,CAAC,UAAU,kBAAkB;YAClD,MAAM,IAAI,IAAI,KAAK;YACnB,IAAI,MAAM,EAAE,OAAO,KAAK;gBACtB,UAAU,IAAI,CAAC;YACjB,OAAO;gBACL,uBAAuB,EAAE,WAAW;YACtC;QACF;QAEA,IAAI,UAAU,MAAM,GAAG,GAAG;YACxB,OAAO,IAAI,CAAC;gBACV,YAAY;gBACZ,eAAe,UAAU,IAAI,CAAC;gBAC9B,cAAc;YAChB;YACA;QACF;QAEA,MAAM,qBAAqB,mBAAmB;QAC9C,MAAM,mBAAmB,mBAAmB;QAE5C,MAAM,aAAkB;YACtB,QAAQ;YACR,eAAe;YACf,MAAM,QAAQ;YACd,MAAM,mBAAmB;YACzB,UAAU;YACV,QAAQ;YACR;YACA;YACA,SAAS,mBAAmB;YAC5B,SAAS,mBAAmB;YAC5B,kBAAkB;YAClB,kBAAkB,IAAA,2IAAoB,EAAC,oBAAoB,kBAAkB,QAAQ;YACrF,cAAc,IAAA,uIAAgB,EAAC,kBAAkB,kBAAkB,MAAM;QAC3E;QAEA,IAAI,WAAW,WAAW,UAAU,GAAG;QACvC,IAAI,YAAY,WAAW,WAAW,GAAG;QACzC,IAAI,sBAAsB,WAAW,sBAAsB,GAAG;QAE9D,MAAM,EAAE,OAAO,WAAW,EAAE,GAAG,MAAM,MAClC,IAAI,CAAC,iBACL,MAAM,CAAC;QAEV,IAAI,aAAa;YACf,OAAO,IAAI,CAAC;gBACV,YAAY;gBACZ,eAAe,YAAY,OAAO;gBAClC,cAAc;YAChB;QACF,OAAO;YACL;QACF;IACF;IAEA,IAAI,OAAO,MAAM,GAAG,GAAG;QACrB,MAAM,eAAe,OAAO,GAAG,CAAC,CAAC,IAAM,CAAC;gBACtC,QAAQ;gBACR,YAAY,EAAE,UAAU;gBACxB,eAAe,EAAE,aAAa;gBAC9B,cAAc,EAAE,YAAY;YAC9B,CAAC;QACD,MAAM,MAAM,IAAI,CAAC,iBAAiB,MAAM,CAAC;IAC3C;IAEA,MAAM,cAAc,gBAAgB,IAAI,cAAc,OAAO,MAAM,GAAG,IAAI,WAAW;IAErF,MAAM,MACH,IAAI,CAAC,eACL,MAAM,CAAC;QACN,gBAAgB;QAChB,aAAa,OAAO,MAAM;QAC1B,eAAe;QACf,QAAQ;QACR,cAAc,IAAI,OAAO,WAAW;IACtC,GACC,EAAE,CAAC,MAAM;IAEZ,OAAO,gJAAY,CAAC,IAAI,CAAC;QACvB;QACA;QACA,YAAY,OAAO,MAAM;QACzB;QACA,WAAW,QAAQ,MAAM;QACzB,QAAQ,OAAO,KAAK,CAAC,GAAG;QACxB;IACF;AACF"}}]
}